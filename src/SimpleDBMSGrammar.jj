options{  static = true;
  DEBUG_PARSER = false;}PARSER_BEGIN(SimpleDBMSParser)
public class SimpleDBMSParser{
  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SHOW_TABLES = 4;  public static final int PRINT_SELECT = 5;  public static final int PRINT_INSERT = 6;  public static final int PRINT_DELETE = 7;  // 나중에 Database로 쓰일 자료 구조 등록  // 테이블 컬럼 등을 기록할 공간도 필요  // 테이블 리스트를 담을 것도
    public static void main(String args[]) throws ParseException  {    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    while (true)    {      try      {
        System.out.print("DB_2014-11663> ");        parser.command();      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }  }

  public static void printMessage(int q)  {
    switch(q)    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;      case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;      case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;      case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;    }
  }}PARSER_END(SimpleDBMSParser)SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */
{
  < EXIT : "exit" >| < CREATE : "create" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < DROP : "drop" >| < TABLE : "table" >| < DESC : "desc" >| < SHOW : "show" >| < TABLES : "tables" >| < SELECT : "select" >| < STAR : "*" >| < AS : "as" >| < FROM : "from" >| < INSERT : "insert" >| < INTO : "into" >| < VALUES : "values" >| < DELETE : "delete" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < IS : "is" >| < NOT : "not" >| < NULL : "null" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < PERIOD : "." >| < UNDERSCORE : "_" >| < GREATER : ">" >| < LESS : "<" >| < EQUAL : "=" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < NOT_EQUAL : "!=" >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTER > | " " >| < DIGIT : [ "0"-"9" ] >| < ALPHABET : [ "A"-"Z", "a"-"z" ] >| < NON_QUOTE_SPECIAL_CHARACTER : ~["\"", "'"] >| < QUOTE : "\"" | "'" >} // 먼저 나와서 밑의 것을 덮을 위험이 있는 것들은 밑으로 빼냄 (더 좁은 의미를 위로)

void command() :
{}{  queryList()
| (
    < EXIT >
    < SEMICOLON >
    {      System.exit(0);
    }
  )}

void queryList() :
{
  int q;
}{
  (    q = query()
    < SEMICOLON >
    {      System.out.print("DB_2014-11663> ");      printMessage(q);
    }
  )+}

int query() :
{
  int q;
}{  (    createTableQuery()
    {      q = PRINT_CREATE_TABLE;
    }  | dropTableQuery()    {      q = PRINT_DROP_TABLE;    }  | showQuery()    {      q = PRINT_SHOW_TABLES;    }  | descQuery()    {      q = PRINT_DESC;    }  | selectQuery()    {      q = PRINT_SELECT;    }  | insertQuery()    {      q = PRINT_INSERT;    }  | deleteQuery()    {      q = PRINT_DELETE;    }
  )
  (    {      return q;
    }
  )
}

void createTableQuery() :
{}{  < CREATE > < TABLE >
  tableName()
  tableElementList()
}

void tableElementList() :
{}{
  < LEFT_PAREN >
  tableElement()
  (    < COMMA >
    tableElement()
  )*
  < RIGHT_PAREN >}

void tableElement() :
{}{
  columnDefinition()
| tableConstraintDefinition()}

void columnDefinition() :
{}{  columnName()
  dataType()
  (    < NOT > < NULL >
  )?
}void dataType() :{}{  < INT >| (    < CHAR >    < LEFT_PAREN >    < INT_VALUE >    < RIGHT_PAREN >  )| < DATE >}

void tableConstraintDefinition() :
{}{  primaryKeyConstraint()
| referentialConstraint()
}

void primaryKeyConstraint() :
{}{
  < PRIMARY > < KEY >
  columnNameList()}

void referentialConstraint() :
{}{
  < FOREIGN > < KEY >
  columnNameList()
  < REFERENCES >
  tableName()
  columnNameList()}void dropTableQuery() :{}{  // table name list에 있는 테이블을 골라서 없애버림 (null로) 그 후 테이블 리스트에서도 삭제  < DROP > < TABLE >  tableNameList()}void showQuery() :{}{  // 현재 있는 테이블 목록을 보여줌  < SHOW > < TABLES >}void descQuery() :{}{  // 구성을 보여줌  < DESC >  tableNameList()}void tableNameList() :{}{  // 모두나 이어붙인 스트링 어레이 반환  < STAR >| tableName()  (    < COMMA >    tableName()  )*}void selectQuery() :{}{  // table expression에서 selectList인 것들만 반환  < SELECT >  selectList()  tableExpression()}void selectList() :{}{  // 전부 다 나 밑의 스트링 어레이 리턴  < STAR >| selectedColumn()  (    < COMMA >    selectedColumn()  )*  /* 나중에 String Array 반환 */}void selectedColumn() :{}{  // 이에 맞는 키 값만 찾아서 리스트로 구성 후 리턴..?  (    LOOKAHEAD(5)    tableName()    < PERIOD >  )?  columnName()  (    < AS >    columnName()  )?	}void tableExpression() :{}{  // from의 결과를 where에 넣어서 비교해서 골라내서 리턴  fromClause()  (    whereClause()  )*}void fromClause() :{}{  // table의 정보를 리턴  < FROM >  tableReferenceList()}void tableReferenceList() :{}{  // 받은 것을 계속 이어 붙여 나간 리스트를 반환. 아니면 expend한 hash?  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable() :{}{  // 앞의 것의 내용을 뒤의 것의 이름으로 리턴   tableName()  (    < AS >    tableName()  )?}void predicate() :{}{  // 계산 결과를 리턴  LOOKAHEAD(4) // 이 밑의 것들은 <LEGAL_ID>가 계속 나와서 4번은 미리 봐두어야 함  comparisonPredicate()| nullPredicate()}void comparisonPredicate() :{}{  // comp operand가 같은 타입인지 확인도 해야할 것 같고 일단 comp operator에 맞게 계산한 boolean을 리턴  compOperand()  compOp()  compOperand()}void compOperand() :{}{  comparableValue()| (    LOOKAHEAD(2) // table name인지 column name인지 2번은 미리 확인해야한다    tableName()    < PERIOD >  )?  columnName()}void compOp() :{}{  // comp operator에 따라 integer을 리턴   (    < LESS >    {          }  | < GREATER >    {          }  | < EQUAL >    {          }  | < GREATER_OR_EQUAL >    {          }  | < LESS_OR_EQUAL >    {          }  | < NOT_EQUAL >    {          }  )  (    {          }  )}void nullPredicate() :{}{  // table name의 column name이 (not) null 인지 확인한 boolean을 리턴  (    LOOKAHEAD(2) // table name인지 column name인지 2번은 미리 확인해야한다    tableName()    < PERIOD >  )?  columnName()  < IS >  (    < NOT >  )?  < NULL >}void insertQuery() :{}{  // table name인 테이블 레코드에 밑의 것을 추가시킨다. table name의 컬럼들을 살펴보고 부족하면 그 부분은 null로 한다 (not null 인지 확인도) 이상한 키값이 있으면 에러  < INSERT > < INTO >  tableName()  insertColumnsAndSource()}void insertColumnsAndSource() :{}{  // column name list 가 있으면 그것을 키로 하여 value list를 하나씩 구성한다. 둘 다 array list로 받고 순서대로 짝지어주는 것이 좋을 것 같음  (    columnNameList()  )?  valueList()}void columnNameList() :{}{  // column name들을 리스트로 넘겨준다  < LEFT_PAREN >  columnName()  (    < COMMA >    columnName()  )*  < RIGHT_PAREN >}void columnName() :{}{  // column name을 string으로 넘겨준다  < LEGAL_IDENTIFIER >}void valueList() :{}{  // value list를 어레이나 해시 테이블로 넘겨주어야 할 것만 같다. 키는 주어준 것을 사용하거나 1st 2nd 3rd 같은 임시의 것을 사용하는 것이 좋을지도  < VALUES >  < LEFT_PAREN >  value()  (    < COMMA >    value()  )*  < RIGHT_PAREN >}void value() :{}{  // null을 리턴하거나 comparable value을 리턴  < NULL >| comparableValue()}void comparableValue() :{}{  // integer, string, string 으로 계산해서 리턴  < INT_VALUE >| < CHAR_STRING >| < DATE_VALUE >}void deleteQuery() :{}{  // 데베 자료구조에서 table 네임을 찾아서 그 멤버들을 where절이 있으면 조건에 맞나 확인하고 없애고 아니면 그냥 비워버린다  < DELETE > < FROM >  tableName()  (    whereClause()  )?}void tableName() :{}{  // string으로 리턴?  < LEGAL_IDENTIFIER >}void whereClause() :{}{  // boolean value expression 을 계산해서 리턴 (어디에 담아두고 리턴?)  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  // boolean value expression이 있으면 받아서 or해서 리턴  booleanTerm()  (    < OR >    booleanValueExpression()  )?}void booleanTerm() :{}{  // boolean term이 있으면 받아서 and해서 리턴  booleanFactor()  (    < AND >    booleanTerm()  )?}void booleanFactor() :{}{  // not이 있으면 not을 붙여서 리턴하고 아니면 boolean test를 리턴  (    < NOT >  )?  booleanTest()}void booleanTest() :{}{  // predicate와 parenthesized boolean expression을 리턴해야 함  predicate()| parenthesizedBooleanExpression()}void parenthesizedBooleanExpression() :{}{  // boolean value expression을 리턴해야 함  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}